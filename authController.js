// #2 именно в этом файле мы будем описывать все функции по взаимодействию с пользователем, т.e. функции по регистрации,
// по авторизации, и по получению пользователей (get users)

const User = require('./models/User')
const Role = require('./models/Role')
// импортируем сюда две созданные модели

const bcrypt = require('bcryptjs')
// импортируем модуль для хеша паролей

const jwt = require('jsonwebtoken')
// импортируем jwt токен

const { validationResult } = require('express-validator')
// экспортируем функцию validationResult для возращения ошибок которые были получены в ходе валидации

const { secret } = require('./config')
// этот секретный ключ (не весь файл) импортируем в наш контроллер через деструктиризацию

const generateAccessToken = (id, roles) => {
  // создали функцию которая будет принимать id токена и его роли.

  const paylod = { id, roles }
  // в обьект paylod внутрь токена мы помещаем id, roles, можем помещать любую информацию сюда

  return jwt.sign(paylod, secret, { expiresIn: '24h' })
  // эта функция должна вернуть нам токен, для этого у модуля jwt вызыввем функцию sign первым параметром принимает обьект paylod,
  // a вторым секретный ключ который создадим в отдельном файле config.js. Именно по этому секретному ключу будет расшифровываться токен
  // expiresIn означает продолжительность жизни токена тут установили 24 часа
}

class authController {
  async registration(req, res) {
    // 1) ФУНКЦИЯ ДЛЯ РЕГИСТРАЦИИ

    try {
      const errors = validationResult(req)
      // тут вызываем импортированную выше функцию validationResult и параметром передаем req запрос, он из него выцепит необходимые поля и провалидирует

      if (!errors.isEmpty()) {
        // если массив этих ошибок не пустой то см ниже:

        return res
          .status(400)
          .json({ message: 'Ошибка при регистрации', errors })
        // возращаем на клиент код ошибки, текст ошибки, и сами эти ошибки можно еще и как нибудь обработать
      }

      const { username, password } = req.body
      // вытаскиваем username, password из тела запроса с помощью деструктиризации

      const candidate = await User.findOne({ username })
      // проверяем есть ли пользователь с таким именем уже у нас в бд, в функцию findOne(передаем обьект и username)

      if (candidate) {
        return res
          .status(400)
          .json({ message: 'Пользователь с таким именем уже существует' }) // если такой пользоваетль уже есть в бд то
        // в json передаем что юзер с таким именем уже есть
      }

      // если пользователя не нашли с таким именем то следующие шаги делаем:
      const hashPassword = bcrypt.hashSync(password, 7)
      // с помощью модуля bcrypt хешируем пароль передаем два параметра- password и степень сложности хеширования 7

      const userRole = await Role.findOne({ value: 'USER' }) // находим роль
      // получаем с бд  обьект роль пользователя, делаем этого пользователя просто USER

      const user = new User({
        username,
        password: hashPassword,
        roles: [userRole.value],
      })
      // создаем пользователя. передаем в обьект username, и как пароль в модельку user передаем этот уже захешированный пароль
      // и в бд этот пароль будет храниться как закешированный. И в массив ролей -roles: передаем поле value из той роли которую мы получили. Т.e. мы получили
      // обьект и из него нам надо выцепить value.

      await user.save()
      // сохраняем пользователя как мы сохраняли роли

      return res.json({ message: 'Пользователь успешно зарегистрирован' })
      // вернули ответ на клиент
    } catch (e) {
      console.log(e)
      res.status(400).json({ message: 'Ошибка регистрации' }) // в json передаем обьект с выводом ошибки пользователю
    }
  } //---------------------------------------------------------------------------------------------------------
  async login(req, res) {
    // 2) ФУНКЦИЯ ДЛЯ АВТОРИЗАЦИИ

    try {
      const { username, password } = req.body
      // из тела запроса вытаскиваем с помощью деструктиризации - username, password

      const user = await User.findOne({ username })
      // находим юзера с таким именем в базе данных

      if (!user) {
        // если пользователь не был найден то см ниже:

        return res
          .status(400) // опять же возвращаем на клиент статус 400
          .json({ message: `Пользователь с ${username} не найден` })
      } // и сообщение что пользователь с таким именем не найден

      const validPassword = bcrypt.compareSync(password, user.password)
      // если пользователь с таким именем найден то нужно сравнить пароли (пароль который в бд и пароль который пришел в теле запроса)
      // создали переменную validPassword в которой хранится логическое значение- валиден ли пароль или нет, с помощью функции compareSync
      // мы сравниваем закешированный пароль и обычный. Первым параметром передаем обычный пароль а вторым закешированный. Закешированный получаем с того пользователя
      // которого мы получили с базы данных user.password

      if (!validPassword) {
        // если пароль не валидный то см ниже:

        return res.status(400).json({ message: `Введите вверный пароль` })
        // опять же возвращаем на клиент статус 400 и сообщение пользователю
      }

      const token = generateAccessToken(user._id, user.roles)
      // если все ок то, в переменную token мы будем возращать результат функции (сам токен) которую мы создадим. В вызов этой функции передаем id пользователя
      // user._id нижнее подчеркивание формирует само mongo, означает что поле не может изменяться. и user.roles

      return res.json(token)
      // возвращаем этот токен на клиент
    } catch (e) {
      console.log(e)
      res.status(400).json({ message: 'Ошибка авторизации' }) // в json передаем обьект с выводом ошибки пользователю
    }
  } //---------------------------------------------------------------------------------------------------------
  async getUsers(req, res) {
    // 3) ФУНКЦИЯ ДЛЯ ПОЛУЧЕНИЯ ПОЛЬЗОВАТЕЛЕЙ

    try {
      const users = await User.find()
      // Запрашиваем у бд пользователей. делаем запрос к бд через функцию find куда ничего не передаем

      res.json(users)
      // возвращаем от сервера массив этих пользователей

      const userRole = new Role()
      const adminRole = new Role({ value: 'ADMIN' })
      // создали прямо внутри функции пару ролей в бд. Создали роли одну для пользователя, другую для админа путем создания обьекта из модели Role,
      // в модели админа указываем само значение, для user это делать не надо так как он по дефолту будет USER. потом эти две строки необходимо удалить

      await userRole.save()
      await adminRole.save()
      // и аснхронно сохраняем эти роли в бд с помощью mongo. Эти роли должны были создаться в личном кабинете mongo db. потом это тоже удаляем
    } catch (e) {
      console.log(e)
      res
        .status(400)
        .json({ message: 'Извините, у вас нет нужных прав доступа' }) // в json передаем обьект с выводом ошибки пользователю
    }
  }
}
// создали класс внутри которого три функции, это регистрация, авторизация, получение пользователей
// класс нужен чтобы скомповать все три функции в одную сущность, эти функции должны принимать два параметра req -запрос, res -ответ
// из req мы будем вытаскивать информацию которую будет присылать пользователь, а с помощью res мы будем этому пользователю что-то возвращать

module.exports = new authController()
// эспортируем из этого модуля обьект этого класса
